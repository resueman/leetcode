package main

import "strconv"

// https://leetcode.com/problems/summary-ranges/description/

// 228. Summary Ranges
// (Дан отсортированный слайс уникальных чисел. Вернуть наименьший список диапазонов / отрезков, покрывающий все числа)
// sort.Ints(nums)

// Вопросы
// 1. Отсортированы ли элементы? (тут да)
// 2. Уникальны ли элементы? (тут да)
// 3. Может ли подаваться пустой слайс?

// Идея:
// Добавляем дубликат последнего в конец, чтобы обработать все элементы в цикле, без хвостиков после.
// Заводим left = 0 указывающий на начало нового диапазона. Идем в цикле с 1.
// Если разница между текущим и предыдущим == 1 (nums[r] - nums[r -1]) тогда continue.
// Иначе сравниваем right и left и в зависимости от разницы между ними создаем новый диапазон.
// После обновляем left = right.

// 2 указателя
// добавление доп. элемента в конец исходного слайса
// сортировка (на собесе мб)
// конвертация int -> string

// Сложность
// Time: O(N) т.к. массив отсортирован по условию. Иначе O(NlogN)
// Space: только массив для ответа

func summaryRanges(nums []int) []string {
	if len(nums) == 0 {
		return []string{}
	}

	// добавляем дубликат последнего в конец, чтобы обработать все элементы в цикле, без хвостиков после
	// по условию все значения уникальны, поэтому у нас сработает добавление нового отрезка в ответ, когда встретим дубликат
	last := nums[len(nums)-1]
	nums = append(nums, last)

	ranges := []string{}
	l := 0
	for r := 1; r < len(nums); r++ {
		if nums[r]-nums[r-1] == 1 { // все значения уникальны, поэтому условие таково
			continue
		}

		var newRange string
		if r-l == 1 {
			newRange = strconv.Itoa(nums[l])
		} else {
			newRange = strconv.Itoa(nums[l]) + "->" + strconv.Itoa(nums[r-1])
		}
		ranges = append(ranges, newRange)

		l = r
	}

	return ranges
}
